// Autogenerated by Thrift Compiler (0.14.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(deprecated)]
#![allow(unreachable_patterns)]
#![allow(unused_variables)]
#![allow(clippy::too_many_arguments, clippy::type_complexity)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TConsensusGroupType {
  ConfigRegion = 0,
  DataRegion = 1,
  SchemaRegion = 2,
}

impl TConsensusGroupType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConsensusGroupType> {
    let enum_value = i_prot.read_i32()?;
    TConsensusGroupType::try_from(enum_value)  }
}

impl TryFrom<i32> for TConsensusGroupType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TConsensusGroupType::ConfigRegion),
      1 => Ok(TConsensusGroupType::DataRegion),
      2 => Ok(TConsensusGroupType::SchemaRegion),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TConsensusGroupType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRegionMigrateFailedType {
  AddPeerFailed = 0,
  RemovePeerFailed = 1,
  RemoveConsensusGroupFailed = 2,
  DeleteRegionFailed = 3,
  CreateRegionFailed = 4,
  Disconnect = 5,
}

impl TRegionMigrateFailedType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionMigrateFailedType> {
    let enum_value = i_prot.read_i32()?;
    TRegionMigrateFailedType::try_from(enum_value)  }
}

impl TryFrom<i32> for TRegionMigrateFailedType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRegionMigrateFailedType::AddPeerFailed),
      1 => Ok(TRegionMigrateFailedType::RemovePeerFailed),
      2 => Ok(TRegionMigrateFailedType::RemoveConsensusGroupFailed),
      3 => Ok(TRegionMigrateFailedType::DeleteRegionFailed),
      4 => Ok(TRegionMigrateFailedType::CreateRegionFailed),
      5 => Ok(TRegionMigrateFailedType::Disconnect),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRegionMigrateFailedType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRegionMaintainTaskStatus {
  TaskNotExist = 0,
  Processing = 1,
  Success = 2,
  Fail = 3,
}

impl TRegionMaintainTaskStatus {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionMaintainTaskStatus> {
    let enum_value = i_prot.read_i32()?;
    TRegionMaintainTaskStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for TRegionMaintainTaskStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRegionMaintainTaskStatus::TaskNotExist),
      1 => Ok(TRegionMaintainTaskStatus::Processing),
      2 => Ok(TRegionMaintainTaskStatus::Success),
      3 => Ok(TRegionMaintainTaskStatus::Fail),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRegionMaintainTaskStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ThrottleType {
  RequestNumber = 0,
  RequestSize = 1,
  WriteNumber = 2,
  WriteSize = 3,
  ReadNumber = 4,
  ReadSize = 5,
}

impl ThrottleType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThrottleType> {
    let enum_value = i_prot.read_i32()?;
    ThrottleType::try_from(enum_value)  }
}

impl TryFrom<i32> for ThrottleType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ThrottleType::RequestNumber),
      1 => Ok(ThrottleType::RequestSize),
      2 => Ok(ThrottleType::WriteNumber),
      3 => Ok(ThrottleType::WriteSize),
      4 => Ok(ThrottleType::ReadNumber),
      5 => Ok(ThrottleType::ReadSize),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ThrottleType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TServiceType {
  ConfigNodeInternalService = 0,
  DataNodeInternalService = 1,
  DataNodeMPPService = 2,
  DataNodeExternalService = 3,
}

impl TServiceType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServiceType> {
    let enum_value = i_prot.read_i32()?;
    TServiceType::try_from(enum_value)  }
}

impl TryFrom<i32> for TServiceType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TServiceType::ConfigNodeInternalService),
      1 => Ok(TServiceType::DataNodeInternalService),
      2 => Ok(TServiceType::DataNodeMPPService),
      3 => Ok(TServiceType::DataNodeExternalService),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TServiceType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TAggregationType {
  Count = 0,
  Avg = 1,
  Sum = 2,
  FirstValue = 3,
  LastValue = 4,
  MaxTime = 5,
  MinTime = 6,
  MaxValue = 7,
  MinValue = 8,
  Extreme = 9,
  CountIf = 10,
  TimeDuration = 11,
  Mode = 12,
  CountTime = 13,
  Stddev = 14,
  StddevPop = 15,
  StddevSamp = 16,
  Variance = 17,
  VarPop = 18,
  VarSamp = 19,
  MaxBy = 20,
  MinBy = 21,
  Udaf = 22,
  First = 23,
  Last = 24,
  FirstBy = 25,
  LastBy = 26,
  Min = 27,
  Max = 28,
  CountAll = 29,
  ApproxCountDistinct = 30,
}

impl TAggregationType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregationType> {
    let enum_value = i_prot.read_i32()?;
    TAggregationType::try_from(enum_value)  }
}

impl TryFrom<i32> for TAggregationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TAggregationType::Count),
      1 => Ok(TAggregationType::Avg),
      2 => Ok(TAggregationType::Sum),
      3 => Ok(TAggregationType::FirstValue),
      4 => Ok(TAggregationType::LastValue),
      5 => Ok(TAggregationType::MaxTime),
      6 => Ok(TAggregationType::MinTime),
      7 => Ok(TAggregationType::MaxValue),
      8 => Ok(TAggregationType::MinValue),
      9 => Ok(TAggregationType::Extreme),
      10 => Ok(TAggregationType::CountIf),
      11 => Ok(TAggregationType::TimeDuration),
      12 => Ok(TAggregationType::Mode),
      13 => Ok(TAggregationType::CountTime),
      14 => Ok(TAggregationType::Stddev),
      15 => Ok(TAggregationType::StddevPop),
      16 => Ok(TAggregationType::StddevSamp),
      17 => Ok(TAggregationType::Variance),
      18 => Ok(TAggregationType::VarPop),
      19 => Ok(TAggregationType::VarSamp),
      20 => Ok(TAggregationType::MaxBy),
      21 => Ok(TAggregationType::MinBy),
      22 => Ok(TAggregationType::Udaf),
      23 => Ok(TAggregationType::First),
      24 => Ok(TAggregationType::Last),
      25 => Ok(TAggregationType::FirstBy),
      26 => Ok(TAggregationType::LastBy),
      27 => Ok(TAggregationType::Min),
      28 => Ok(TAggregationType::Max),
      29 => Ok(TAggregationType::CountAll),
      30 => Ok(TAggregationType::ApproxCountDistinct),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TAggregationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TrainingState {
  Pending = 0,
  Running = 1,
  Finished = 2,
  Failed = 3,
  Dropping = 4,
}

impl TrainingState {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TrainingState> {
    let enum_value = i_prot.read_i32()?;
    TrainingState::try_from(enum_value)  }
}

impl TryFrom<i32> for TrainingState {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TrainingState::Pending),
      1 => Ok(TrainingState::Running),
      2 => Ok(TrainingState::Finished),
      3 => Ok(TrainingState::Failed),
      4 => Ok(TrainingState::Dropping),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TrainingState", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Model {
  Tree = 0,
  Table = 1,
}

impl Model {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Model> {
    let enum_value = i_prot.read_i32()?;
    Model::try_from(enum_value)  }
}

impl TryFrom<i32> for Model {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(Model::Tree),
      1 => Ok(Model::Table),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Model", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum FunctionType {
  None = 0,
  Scalar = 1,
  Aggregate = 2,
  Table = 3,
}

impl FunctionType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FunctionType> {
    let enum_value = i_prot.read_i32()?;
    FunctionType::try_from(enum_value)  }
}

impl TryFrom<i32> for FunctionType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(FunctionType::None),
      1 => Ok(FunctionType::Scalar),
      2 => Ok(FunctionType::Aggregate),
      3 => Ok(FunctionType::Table),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to FunctionType", i)
            )
          )
        )
      },
    }
  }
}

//
// TEndPoint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEndPoint {
  pub ip: String,
  pub port: i32,
}

impl TEndPoint {
  pub fn new(ip: String, port: i32) -> TEndPoint {
    TEndPoint {
      ip,
      port,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEndPoint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TEndPoint.ip", &f_1)?;
    verify_required_field_exists("TEndPoint.port", &f_2)?;
    let ret = TEndPoint {
      ip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEndPoint");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ip", TType::String, 1))?;
    o_prot.write_string(&self.ip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
    o_prot.write_i32(self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSStatus {
  pub code: i32,
  pub message: Option<String>,
  pub sub_status: Option<Vec<Box<TSStatus>>>,
  pub redirect_node: Option<TEndPoint>,
  pub need_retry: Option<bool>,
}

impl TSStatus {
  pub fn new<F2, F3, F4, F5>(code: i32, message: F2, sub_status: F3, redirect_node: F4, need_retry: F5) -> TSStatus where F2: Into<Option<String>>, F3: Into<Option<Vec<Box<TSStatus>>>>, F4: Into<Option<TEndPoint>>, F5: Into<Option<bool>> {
    TSStatus {
      code,
      message: message.into(),
      sub_status: sub_status.into(),
      redirect_node: redirect_node.into(),
      need_retry: need_retry.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Box<TSStatus>>> = None;
    let mut f_4: Option<TEndPoint> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TSStatus>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TSStatus::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSStatus.code", &f_1)?;
    let ret = TSStatus {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2,
      sub_status: f_3,
      redirect_node: f_4,
      need_retry: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
    o_prot.write_i32(self.code)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sub_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("subStatus", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.redirect_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("redirectNode", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.need_retry {
      o_prot.write_field_begin(&TFieldIdentifier::new("needRetry", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TConsensusGroupId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TConsensusGroupId {
  pub type_: TConsensusGroupType,
  pub id: i32,
}

impl TConsensusGroupId {
  pub fn new(type_: TConsensusGroupType, id: i32) -> TConsensusGroupId {
    TConsensusGroupId {
      type_,
      id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConsensusGroupId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TConsensusGroupType> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TConsensusGroupType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TConsensusGroupId.type_", &f_1)?;
    verify_required_field_exists("TConsensusGroupId.id", &f_2)?;
    let ret = TConsensusGroupId {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TConsensusGroupId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 2))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSeriesPartitionSlot
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSeriesPartitionSlot {
  pub slot_id: i32,
}

impl TSeriesPartitionSlot {
  pub fn new(slot_id: i32) -> TSeriesPartitionSlot {
    TSeriesPartitionSlot {
      slot_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSeriesPartitionSlot> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSeriesPartitionSlot.slot_id", &f_1)?;
    let ret = TSeriesPartitionSlot {
      slot_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSeriesPartitionSlot");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slotId", TType::I32, 1))?;
    o_prot.write_i32(self.slot_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTimePartitionSlot
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTimePartitionSlot {
  pub start_time: i64,
}

impl TTimePartitionSlot {
  pub fn new(start_time: i64) -> TTimePartitionSlot {
    TTimePartitionSlot {
      start_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTimePartitionSlot> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTimePartitionSlot.start_time", &f_1)?;
    let ret = TTimePartitionSlot {
      start_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTimePartitionSlot");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 1))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRegionReplicaSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRegionReplicaSet {
  pub region_id: TConsensusGroupId,
  pub data_node_locations: Vec<Box<TDataNodeLocation>>,
}

impl TRegionReplicaSet {
  pub fn new(region_id: TConsensusGroupId, data_node_locations: Vec<Box<TDataNodeLocation>>) -> TRegionReplicaSet {
    TRegionReplicaSet {
      region_id,
      data_node_locations,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionReplicaSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TConsensusGroupId> = None;
    let mut f_2: Option<Vec<Box<TDataNodeLocation>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TConsensusGroupId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TDataNodeLocation>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = Box::new(TDataNodeLocation::read_from_in_protocol(i_prot)?);
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRegionReplicaSet.region_id", &f_1)?;
    verify_required_field_exists("TRegionReplicaSet.data_node_locations", &f_2)?;
    let ret = TRegionReplicaSet {
      region_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      data_node_locations: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRegionReplicaSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("regionId", TType::Struct, 1))?;
    self.region_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeLocations", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.data_node_locations.len() as i32))?;
    for e in &self.data_node_locations {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNodeResource
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeResource {
  pub cpu_core_num: i32,
  pub max_memory: i64,
}

impl TNodeResource {
  pub fn new(cpu_core_num: i32, max_memory: i64) -> TNodeResource {
    TNodeResource {
      cpu_core_num,
      max_memory,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeResource> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TNodeResource.cpu_core_num", &f_1)?;
    verify_required_field_exists("TNodeResource.max_memory", &f_2)?;
    let ret = TNodeResource {
      cpu_core_num: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_memory: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeResource");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpuCoreNum", TType::I32, 1))?;
    o_prot.write_i32(self.cpu_core_num)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxMemory", TType::I64, 2))?;
    o_prot.write_i64(self.max_memory)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TConfigNodeLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TConfigNodeLocation {
  pub config_node_id: i32,
  pub internal_end_point: TEndPoint,
  pub consensus_end_point: TEndPoint,
}

impl TConfigNodeLocation {
  pub fn new(config_node_id: i32, internal_end_point: TEndPoint, consensus_end_point: TEndPoint) -> TConfigNodeLocation {
    TConfigNodeLocation {
      config_node_id,
      internal_end_point,
      consensus_end_point,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConfigNodeLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<TEndPoint> = None;
    let mut f_3: Option<TEndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TConfigNodeLocation.config_node_id", &f_1)?;
    verify_required_field_exists("TConfigNodeLocation.internal_end_point", &f_2)?;
    verify_required_field_exists("TConfigNodeLocation.consensus_end_point", &f_3)?;
    let ret = TConfigNodeLocation {
      config_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      internal_end_point: f_2.expect("auto-generated code should have checked for presence of required fields"),
      consensus_end_point: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TConfigNodeLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("configNodeId", TType::I32, 1))?;
    o_prot.write_i32(self.config_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("internalEndPoint", TType::Struct, 2))?;
    self.internal_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consensusEndPoint", TType::Struct, 3))?;
    self.consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataNodeLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataNodeLocation {
  pub data_node_id: i32,
  pub client_rpc_end_point: TEndPoint,
  pub internal_end_point: TEndPoint,
  pub m_p_p_data_exchange_end_point: TEndPoint,
  pub data_region_consensus_end_point: TEndPoint,
  pub schema_region_consensus_end_point: TEndPoint,
}

impl TDataNodeLocation {
  pub fn new(data_node_id: i32, client_rpc_end_point: TEndPoint, internal_end_point: TEndPoint, m_p_p_data_exchange_end_point: TEndPoint, data_region_consensus_end_point: TEndPoint, schema_region_consensus_end_point: TEndPoint) -> TDataNodeLocation {
    TDataNodeLocation {
      data_node_id,
      client_rpc_end_point,
      internal_end_point,
      m_p_p_data_exchange_end_point,
      data_region_consensus_end_point,
      schema_region_consensus_end_point,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataNodeLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<TEndPoint> = None;
    let mut f_3: Option<TEndPoint> = None;
    let mut f_4: Option<TEndPoint> = None;
    let mut f_5: Option<TEndPoint> = None;
    let mut f_6: Option<TEndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDataNodeLocation.data_node_id", &f_1)?;
    verify_required_field_exists("TDataNodeLocation.client_rpc_end_point", &f_2)?;
    verify_required_field_exists("TDataNodeLocation.internal_end_point", &f_3)?;
    verify_required_field_exists("TDataNodeLocation.m_p_p_data_exchange_end_point", &f_4)?;
    verify_required_field_exists("TDataNodeLocation.data_region_consensus_end_point", &f_5)?;
    verify_required_field_exists("TDataNodeLocation.schema_region_consensus_end_point", &f_6)?;
    let ret = TDataNodeLocation {
      data_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_rpc_end_point: f_2.expect("auto-generated code should have checked for presence of required fields"),
      internal_end_point: f_3.expect("auto-generated code should have checked for presence of required fields"),
      m_p_p_data_exchange_end_point: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data_region_consensus_end_point: f_5.expect("auto-generated code should have checked for presence of required fields"),
      schema_region_consensus_end_point: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataNodeLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeId", TType::I32, 1))?;
    o_prot.write_i32(self.data_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientRpcEndPoint", TType::Struct, 2))?;
    self.client_rpc_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("internalEndPoint", TType::Struct, 3))?;
    self.internal_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mPPDataExchangeEndPoint", TType::Struct, 4))?;
    self.m_p_p_data_exchange_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataRegionConsensusEndPoint", TType::Struct, 5))?;
    self.data_region_consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaRegionConsensusEndPoint", TType::Struct, 6))?;
    self.schema_region_consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAINodeLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAINodeLocation {
  pub ai_node_id: i32,
  pub internal_end_point: TEndPoint,
}

impl TAINodeLocation {
  pub fn new(ai_node_id: i32, internal_end_point: TEndPoint) -> TAINodeLocation {
    TAINodeLocation {
      ai_node_id,
      internal_end_point,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAINodeLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<TEndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAINodeLocation.ai_node_id", &f_1)?;
    verify_required_field_exists("TAINodeLocation.internal_end_point", &f_2)?;
    let ret = TAINodeLocation {
      ai_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      internal_end_point: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAINodeLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("aiNodeId", TType::I32, 1))?;
    o_prot.write_i32(self.ai_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("internalEndPoint", TType::Struct, 2))?;
    self.internal_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataNodeConfiguration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataNodeConfiguration {
  pub location: TDataNodeLocation,
  pub resource: TNodeResource,
}

impl TDataNodeConfiguration {
  pub fn new(location: TDataNodeLocation, resource: TNodeResource) -> TDataNodeConfiguration {
    TDataNodeConfiguration {
      location,
      resource,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataNodeConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDataNodeLocation> = None;
    let mut f_2: Option<TNodeResource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDataNodeLocation::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TNodeResource::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDataNodeConfiguration.location", &f_1)?;
    verify_required_field_exists("TDataNodeConfiguration.resource", &f_2)?;
    let ret = TDataNodeConfiguration {
      location: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataNodeConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 1))?;
    self.location.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::Struct, 2))?;
    self.resource.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAINodeConfiguration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAINodeConfiguration {
  pub location: TAINodeLocation,
  pub resource: TNodeResource,
}

impl TAINodeConfiguration {
  pub fn new(location: TAINodeLocation, resource: TNodeResource) -> TAINodeConfiguration {
    TAINodeConfiguration {
      location,
      resource,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAINodeConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TAINodeLocation> = None;
    let mut f_2: Option<TNodeResource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TAINodeLocation::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TNodeResource::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAINodeConfiguration.location", &f_1)?;
    verify_required_field_exists("TAINodeConfiguration.resource", &f_2)?;
    let ret = TAINodeConfiguration {
      location: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAINodeConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 1))?;
    self.location.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::Struct, 2))?;
    self.resource.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFlushReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFlushReq {
  pub is_seq: Option<String>,
  pub storage_groups: Option<Vec<String>>,
  pub region_ids: Option<Vec<String>>,
}

impl TFlushReq {
  pub fn new<F1, F2, F3>(is_seq: F1, storage_groups: F2, region_ids: F3) -> TFlushReq where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<Vec<String>>> {
    TFlushReq {
      is_seq: is_seq.into(),
      storage_groups: storage_groups.into(),
      region_ids: region_ids.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFlushReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFlushReq {
      is_seq: f_1,
      storage_groups: f_2,
      region_ids: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFlushReq");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.is_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSeq", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.storage_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("storageGroups", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.region_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("regionIds", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TFlushReq {
  fn default() -> Self {
    TFlushReq{
      is_seq: Some("".to_owned()),
      storage_groups: Some(Vec::new()),
      region_ids: Some(Vec::new()),
    }
  }
}

//
// TSettleReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSettleReq {
  pub paths: Vec<String>,
}

impl TSettleReq {
  pub fn new(paths: Vec<String>) -> TSettleReq {
    TSettleReq {
      paths,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSettleReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSettleReq.paths", &f_1)?;
    let ret = TSettleReq {
      paths: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSettleReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchemaNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaNode {
  pub node_name: String,
  pub node_type: i8,
}

impl TSchemaNode {
  pub fn new(node_name: String, node_type: i8) -> TSchemaNode {
    TSchemaNode {
      node_name,
      node_type,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i8> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSchemaNode.node_name", &f_1)?;
    verify_required_field_exists("TSchemaNode.node_type", &f_2)?;
    let ret = TSchemaNode {
      node_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchemaNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeName", TType::String, 1))?;
    o_prot.write_string(&self.node_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeType", TType::I08, 2))?;
    o_prot.write_i8(self.node_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetConfigurationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetConfigurationReq {
  pub configs: BTreeMap<String, String>,
  pub node_id: i32,
}

impl TSetConfigurationReq {
  pub fn new(configs: BTreeMap<String, String>, node_id: i32) -> TSetConfigurationReq {
    TSetConfigurationReq {
      configs,
      node_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetConfigurationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = i_prot.read_string()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetConfigurationReq.configs", &f_1)?;
    verify_required_field_exists("TSetConfigurationReq.node_id", &f_2)?;
    let ret = TSetConfigurationReq {
      configs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetConfigurationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("configs", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.configs.len() as i32))?;
    for (k, v) in &self.configs {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeId", TType::I32, 2))?;
    o_prot.write_i32(self.node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetTTLReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetTTLReq {
  pub path_pattern: Vec<String>,
  pub t_t_l: i64,
  pub is_data_base: bool,
}

impl TSetTTLReq {
  pub fn new(path_pattern: Vec<String>, t_t_l: i64, is_data_base: bool) -> TSetTTLReq {
    TSetTTLReq {
      path_pattern,
      t_t_l,
      is_data_base,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetTTLReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetTTLReq.path_pattern", &f_1)?;
    verify_required_field_exists("TSetTTLReq.t_t_l", &f_2)?;
    verify_required_field_exists("TSetTTLReq.is_data_base", &f_3)?;
    let ret = TSetTTLReq {
      path_pattern: f_1.expect("auto-generated code should have checked for presence of required fields"),
      t_t_l: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_data_base: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetTTLReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pathPattern", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.path_pattern.len() as i32))?;
    for e in &self.path_pattern {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("TTL", TType::I64, 2))?;
    o_prot.write_i64(self.t_t_l)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isDataBase", TType::Bool, 3))?;
    o_prot.write_bool(self.is_data_base)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TShowTTLReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TShowTTLReq {
  pub path_pattern: Vec<String>,
}

impl TShowTTLReq {
  pub fn new(path_pattern: Vec<String>) -> TShowTTLReq {
    TShowTTLReq {
      path_pattern,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TShowTTLReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TShowTTLReq.path_pattern", &f_1)?;
    let ret = TShowTTLReq {
      path_pattern: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TShowTTLReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pathPattern", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.path_pattern.len() as i32))?;
    for e in &self.path_pattern {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFile {
  pub file_name: String,
  pub file: Vec<u8>,
}

impl TFile {
  pub fn new(file_name: String, file: Vec<u8>) -> TFile {
    TFile {
      file_name,
      file,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFile.file_name", &f_1)?;
    verify_required_field_exists("TFile.file", &f_2)?;
    let ret = TFile {
      file_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFile");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileName", TType::String, 1))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file", TType::String, 2))?;
    o_prot.write_bytes(&self.file)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFilesResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFilesResp {
  pub status: TSStatus,
  pub files: Vec<TFile>,
}

impl TFilesResp {
  pub fn new(status: TSStatus, files: Vec<TFile>) -> TFilesResp {
    TFilesResp {
      status,
      files,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFilesResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<Vec<TFile>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TFile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TFile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFilesResp.status", &f_1)?;
    verify_required_field_exists("TFilesResp.files", &f_2)?;
    let ret = TFilesResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      files: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFilesResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("files", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.files.len() as i32))?;
    for e in &self.files {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSpaceQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSpaceQuota {
  pub disk_size: Option<i64>,
  pub device_num: Option<i64>,
  pub timeserie_num: Option<i64>,
}

impl TSpaceQuota {
  pub fn new<F1, F2, F3>(disk_size: F1, device_num: F2, timeserie_num: F3) -> TSpaceQuota where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TSpaceQuota {
      disk_size: disk_size.into(),
      device_num: device_num.into(),
      timeserie_num: timeserie_num.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSpaceQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSpaceQuota {
      disk_size: f_1,
      device_num: f_2,
      timeserie_num: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSpaceQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.disk_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("diskSize", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.device_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceNum", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeserie_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeserieNum", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSpaceQuota {
  fn default() -> Self {
    TSpaceQuota{
      disk_size: Some(0),
      device_num: Some(0),
      timeserie_num: Some(0),
    }
  }
}

//
// TTimedQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTimedQuota {
  pub time_unit: i64,
  pub soft_limit: i64,
}

impl TTimedQuota {
  pub fn new(time_unit: i64, soft_limit: i64) -> TTimedQuota {
    TTimedQuota {
      time_unit,
      soft_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTimedQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTimedQuota.time_unit", &f_1)?;
    verify_required_field_exists("TTimedQuota.soft_limit", &f_2)?;
    let ret = TTimedQuota {
      time_unit: f_1.expect("auto-generated code should have checked for presence of required fields"),
      soft_limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTimedQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeUnit", TType::I64, 1))?;
    o_prot.write_i64(self.time_unit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("softLimit", TType::I64, 2))?;
    o_prot.write_i64(self.soft_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TThrottleQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TThrottleQuota {
  pub throttle_limit: Option<BTreeMap<ThrottleType, TTimedQuota>>,
  pub mem_limit: Option<i64>,
  pub cpu_limit: Option<i32>,
}

impl TThrottleQuota {
  pub fn new<F1, F2, F3>(throttle_limit: F1, mem_limit: F2, cpu_limit: F3) -> TThrottleQuota where F1: Into<Option<BTreeMap<ThrottleType, TTimedQuota>>>, F2: Into<Option<i64>>, F3: Into<Option<i32>> {
    TThrottleQuota {
      throttle_limit: throttle_limit.into(),
      mem_limit: mem_limit.into(),
      cpu_limit: cpu_limit.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TThrottleQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<ThrottleType, TTimedQuota>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<ThrottleType, TTimedQuota> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_10 = ThrottleType::read_from_in_protocol(i_prot)?;
            let map_val_11 = TTimedQuota::read_from_in_protocol(i_prot)?;
            val.insert(map_key_10, map_val_11);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TThrottleQuota {
      throttle_limit: f_1,
      mem_limit: f_2,
      cpu_limit: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TThrottleQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.throttle_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("throttleLimit", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("memLimit", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cpu_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("cpuLimit", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TThrottleQuota {
  fn default() -> Self {
    TThrottleQuota{
      throttle_limit: Some(BTreeMap::new()),
      mem_limit: Some(0),
      cpu_limit: Some(0),
    }
  }
}

//
// TSetSpaceQuotaReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetSpaceQuotaReq {
  pub database: Vec<String>,
  pub space_limit: TSpaceQuota,
}

impl TSetSpaceQuotaReq {
  pub fn new(database: Vec<String>, space_limit: TSpaceQuota) -> TSetSpaceQuotaReq {
    TSetSpaceQuotaReq {
      database,
      space_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetSpaceQuotaReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<TSpaceQuota> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_string()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSpaceQuota::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetSpaceQuotaReq.database", &f_1)?;
    verify_required_field_exists("TSetSpaceQuotaReq.space_limit", &f_2)?;
    let ret = TSetSpaceQuotaReq {
      database: f_1.expect("auto-generated code should have checked for presence of required fields"),
      space_limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetSpaceQuotaReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.database.len() as i32))?;
    for e in &self.database {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spaceLimit", TType::Struct, 2))?;
    self.space_limit.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetThrottleQuotaReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetThrottleQuotaReq {
  pub user_name: String,
  pub throttle_quota: TThrottleQuota,
}

impl TSetThrottleQuotaReq {
  pub fn new(user_name: String, throttle_quota: TThrottleQuota) -> TSetThrottleQuotaReq {
    TSetThrottleQuotaReq {
      user_name,
      throttle_quota,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetThrottleQuotaReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TThrottleQuota> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TThrottleQuota::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetThrottleQuotaReq.user_name", &f_1)?;
    verify_required_field_exists("TSetThrottleQuotaReq.throttle_quota", &f_2)?;
    let ret = TSetThrottleQuotaReq {
      user_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      throttle_quota: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetThrottleQuotaReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 1))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("throttleQuota", TType::Struct, 2))?;
    self.throttle_quota.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLicense
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLicense {
  pub license_issue_timestamp: i64,
  pub expire_timestamp: i64,
  pub data_node_num_limit: i16,
  pub cpu_core_num_limit: i32,
  pub device_num_limit: i64,
  pub sensor_num_limit: i64,
  pub disconnection_from_active_node_time_limit: i64,
  pub ml_node_num_limit: i16,
}

impl TLicense {
  pub fn new(license_issue_timestamp: i64, expire_timestamp: i64, data_node_num_limit: i16, cpu_core_num_limit: i32, device_num_limit: i64, sensor_num_limit: i64, disconnection_from_active_node_time_limit: i64, ml_node_num_limit: i16) -> TLicense {
    TLicense {
      license_issue_timestamp,
      expire_timestamp,
      data_node_num_limit,
      cpu_core_num_limit,
      device_num_limit,
      sensor_num_limit,
      disconnection_from_active_node_time_limit,
      ml_node_num_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLicense> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_4: Option<i16> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i16()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLicense.license_issue_timestamp", &f_1)?;
    verify_required_field_exists("TLicense.expire_timestamp", &f_2)?;
    verify_required_field_exists("TLicense.data_node_num_limit", &f_4)?;
    verify_required_field_exists("TLicense.cpu_core_num_limit", &f_5)?;
    verify_required_field_exists("TLicense.device_num_limit", &f_6)?;
    verify_required_field_exists("TLicense.sensor_num_limit", &f_7)?;
    verify_required_field_exists("TLicense.disconnection_from_active_node_time_limit", &f_8)?;
    verify_required_field_exists("TLicense.ml_node_num_limit", &f_9)?;
    let ret = TLicense {
      license_issue_timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      expire_timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_node_num_limit: f_4.expect("auto-generated code should have checked for presence of required fields"),
      cpu_core_num_limit: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_num_limit: f_6.expect("auto-generated code should have checked for presence of required fields"),
      sensor_num_limit: f_7.expect("auto-generated code should have checked for presence of required fields"),
      disconnection_from_active_node_time_limit: f_8.expect("auto-generated code should have checked for presence of required fields"),
      ml_node_num_limit: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLicense");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("licenseIssueTimestamp", TType::I64, 1))?;
    o_prot.write_i64(self.license_issue_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expireTimestamp", TType::I64, 2))?;
    o_prot.write_i64(self.expire_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeNumLimit", TType::I16, 4))?;
    o_prot.write_i16(self.data_node_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpuCoreNumLimit", TType::I32, 5))?;
    o_prot.write_i32(self.cpu_core_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceNumLimit", TType::I64, 6))?;
    o_prot.write_i64(self.device_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sensorNumLimit", TType::I64, 7))?;
    o_prot.write_i64(self.sensor_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("disconnectionFromActiveNodeTimeLimit", TType::I64, 8))?;
    o_prot.write_i64(self.disconnection_from_active_node_time_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mlNodeNumLimit", TType::I16, 9))?;
    o_prot.write_i16(self.ml_node_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLoadSample
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLoadSample {
  pub cpu_usage_rate: OrderedFloat<f64>,
  pub memory_usage_rate: OrderedFloat<f64>,
  pub disk_usage_rate: OrderedFloat<f64>,
  pub free_disk_space: OrderedFloat<f64>,
}

impl TLoadSample {
  pub fn new(cpu_usage_rate: OrderedFloat<f64>, memory_usage_rate: OrderedFloat<f64>, disk_usage_rate: OrderedFloat<f64>, free_disk_space: OrderedFloat<f64>) -> TLoadSample {
    TLoadSample {
      cpu_usage_rate,
      memory_usage_rate,
      disk_usage_rate,
      free_disk_space,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLoadSample> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = None;
    let mut f_2: Option<OrderedFloat<f64>> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLoadSample.cpu_usage_rate", &f_1)?;
    verify_required_field_exists("TLoadSample.memory_usage_rate", &f_2)?;
    verify_required_field_exists("TLoadSample.disk_usage_rate", &f_3)?;
    verify_required_field_exists("TLoadSample.free_disk_space", &f_4)?;
    let ret = TLoadSample {
      cpu_usage_rate: f_1.expect("auto-generated code should have checked for presence of required fields"),
      memory_usage_rate: f_2.expect("auto-generated code should have checked for presence of required fields"),
      disk_usage_rate: f_3.expect("auto-generated code should have checked for presence of required fields"),
      free_disk_space: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLoadSample");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpuUsageRate", TType::Double, 1))?;
    o_prot.write_double(self.cpu_usage_rate.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("memoryUsageRate", TType::Double, 2))?;
    o_prot.write_double(self.memory_usage_rate.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("diskUsageRate", TType::Double, 3))?;
    o_prot.write_double(self.disk_usage_rate.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("freeDiskSpace", TType::Double, 4))?;
    o_prot.write_double(self.free_disk_space.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TServiceProvider
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TServiceProvider {
  pub end_point: TEndPoint,
  pub service_type: TServiceType,
  pub node_id: i32,
}

impl TServiceProvider {
  pub fn new(end_point: TEndPoint, service_type: TServiceType, node_id: i32) -> TServiceProvider {
    TServiceProvider {
      end_point,
      service_type,
      node_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TServiceProvider> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TEndPoint> = None;
    let mut f_2: Option<TServiceType> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TServiceType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TServiceProvider.end_point", &f_1)?;
    verify_required_field_exists("TServiceProvider.service_type", &f_2)?;
    verify_required_field_exists("TServiceProvider.node_id", &f_3)?;
    let ret = TServiceProvider {
      end_point: f_1.expect("auto-generated code should have checked for presence of required fields"),
      service_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      node_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TServiceProvider");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endPoint", TType::Struct, 1))?;
    self.end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serviceType", TType::I32, 2))?;
    self.service_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeId", TType::I32, 3))?;
    o_prot.write_i32(self.node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSender
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSender {
  pub data_node_location: Option<TDataNodeLocation>,
  pub config_node_location: Option<TConfigNodeLocation>,
}

impl TSender {
  pub fn new<F1, F2>(data_node_location: F1, config_node_location: F2) -> TSender where F1: Into<Option<TDataNodeLocation>>, F2: Into<Option<TConfigNodeLocation>> {
    TSender {
      data_node_location: data_node_location.into(),
      config_node_location: config_node_location.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSender> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDataNodeLocation> = None;
    let mut f_2: Option<TConfigNodeLocation> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDataNodeLocation::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TConfigNodeLocation::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSender {
      data_node_location: f_1,
      config_node_location: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSender");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data_node_location {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeLocation", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.config_node_location {
      o_prot.write_field_begin(&TFieldIdentifier::new("configNodeLocation", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSender {
  fn default() -> Self {
    TSender{
      data_node_location: None,
      config_node_location: None,
    }
  }
}

//
// TTestConnectionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTestConnectionResult {
  pub service_provider: TServiceProvider,
  pub sender: TSender,
  pub success: bool,
  pub reason: Option<String>,
}

impl TTestConnectionResult {
  pub fn new<F4>(service_provider: TServiceProvider, sender: TSender, success: bool, reason: F4) -> TTestConnectionResult where F4: Into<Option<String>> {
    TTestConnectionResult {
      service_provider,
      sender,
      success,
      reason: reason.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTestConnectionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TServiceProvider> = None;
    let mut f_2: Option<TSender> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TServiceProvider::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSender::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTestConnectionResult.service_provider", &f_1)?;
    verify_required_field_exists("TTestConnectionResult.sender", &f_2)?;
    verify_required_field_exists("TTestConnectionResult.success", &f_3)?;
    let ret = TTestConnectionResult {
      service_provider: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sender: f_2.expect("auto-generated code should have checked for presence of required fields"),
      success: f_3.expect("auto-generated code should have checked for presence of required fields"),
      reason: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTestConnectionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serviceProvider", TType::Struct, 1))?;
    self.service_provider.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sender", TType::Struct, 2))?;
    self.sender.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("success", TType::Bool, 3))?;
    o_prot.write_bool(self.success)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTestConnectionResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTestConnectionResp {
  pub status: TSStatus,
  pub result_list: Vec<TTestConnectionResult>,
}

impl TTestConnectionResp {
  pub fn new(status: TSStatus, result_list: Vec<TTestConnectionResult>) -> TTestConnectionResp {
    TTestConnectionResp {
      status,
      result_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTestConnectionResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<Vec<TTestConnectionResult>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTestConnectionResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = TTestConnectionResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTestConnectionResp.status", &f_1)?;
    verify_required_field_exists("TTestConnectionResp.result_list", &f_2)?;
    let ret = TTestConnectionResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      result_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTestConnectionResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resultList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.result_list.len() as i32))?;
    for e in &self.result_list {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNodeLocations
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeLocations {
  pub config_node_locations: Option<Vec<TConfigNodeLocation>>,
  pub data_node_locations: Option<Vec<TDataNodeLocation>>,
}

impl TNodeLocations {
  pub fn new<F1, F2>(config_node_locations: F1, data_node_locations: F2) -> TNodeLocations where F1: Into<Option<Vec<TConfigNodeLocation>>>, F2: Into<Option<Vec<TDataNodeLocation>>> {
    TNodeLocations {
      config_node_locations: config_node_locations.into(),
      data_node_locations: data_node_locations.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeLocations> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TConfigNodeLocation>> = None;
    let mut f_2: Option<Vec<TDataNodeLocation>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TConfigNodeLocation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = TConfigNodeLocation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TDataNodeLocation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = TDataNodeLocation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TNodeLocations {
      config_node_locations: f_1,
      data_node_locations: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeLocations");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.config_node_locations {
      o_prot.write_field_begin(&TFieldIdentifier::new("configNodeLocations", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_node_locations {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeLocations", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TNodeLocations {
  fn default() -> Self {
    TNodeLocations{
      config_node_locations: Some(Vec::new()),
      data_node_locations: Some(Vec::new()),
    }
  }
}

//
// TShowConfigurationTemplateResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TShowConfigurationTemplateResp {
  pub status: TSStatus,
  pub content: String,
}

impl TShowConfigurationTemplateResp {
  pub fn new(status: TSStatus, content: String) -> TShowConfigurationTemplateResp {
    TShowConfigurationTemplateResp {
      status,
      content,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TShowConfigurationTemplateResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TShowConfigurationTemplateResp.status", &f_1)?;
    verify_required_field_exists("TShowConfigurationTemplateResp.content", &f_2)?;
    let ret = TShowConfigurationTemplateResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      content: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TShowConfigurationTemplateResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 2))?;
    o_prot.write_string(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TShowConfigurationResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TShowConfigurationResp {
  pub status: TSStatus,
  pub content: String,
}

impl TShowConfigurationResp {
  pub fn new(status: TSStatus, content: String) -> TShowConfigurationResp {
    TShowConfigurationResp {
      status,
      content,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TShowConfigurationResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TShowConfigurationResp.status", &f_1)?;
    verify_required_field_exists("TShowConfigurationResp.content", &f_2)?;
    let ret = TShowConfigurationResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      content: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TShowConfigurationResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 2))?;
    o_prot.write_string(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

